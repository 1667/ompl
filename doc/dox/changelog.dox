/**

\page changelog

\section oct_07_2010 October 7, 2010
	- Added the concept of MotionValidator for checking validity of path segments.
	- The collision checking resolution is a percentage of the extent of the entire space
	- Generic termination conditions for planners
	- Added benchmakring for planning under geometric constraints
	- Added registerDefaultProjection() for StateManifold.

\section aug_09_2010 August 9, 2010

	- Including the following sampling-based motion planning alorithms (inherit from ompl::base::Planner):
		- planning under geometric constraints: KPIECE, LBKPIECE, SBL,
		pSBL, EST, RRT, pRRT, RRTConnect, LazyRRT, PRM
		- planning under differential constraints: KPIECE, RRT

	- The representation of states (ompl::base::State) is abstract:
	manifolds that operate on states (ompl::base::StateManifold) and
	controls (ompl::control::ControlManifold) need to be
	defined. Based on the topology-specific functionality offered by
	these manifolds, primitives used by algorithms are
	implemented (ompl::base::SpaceInformation and
	ompl::control::SpaceInformation). Euclidean projections are
	defined for StateManifold using registerProjection()

	- The representation of goals is abstract. In the most general
	case, a goal is a predicate function that states whether the goal
	has been reached or not (ompl::base::Goal). More specifically, the
	goal can designate a region and can compute an approximate
	distance to this region (ompl::base::GoalRegion). This is useful
	when biasing planners is desirable. A further layer of abstraction
	allows sampling these
	regions (ompl::base::GoalSampleableRegion). Instantiations of this
	latter abstraction for a goal state (ompl::base::GoalState) and a
	set of states (ompl::base::GoalStates) are provided.

	- The start states and goal representation are specified as a
	problem definition (ompl::base::ProblemDefinition)

	- State validity checking is external to this
	library (ompl::base::StateValidityChecker).

	- Support for Python bindings

*/
