/** \page newPlanner Implementing a new motion planner

    In order to implement a new motion planner the following rules
    need to be followed:
    - Define the new planner as a class that inherits from ompl::base::Planner
    - Provide an implementation of ompl::base::Planner::solve(). We
      suggest leveraging the implementations of the routines available
      in ompl::base::SpaceInformation, but this is not required.
      	 - If a solution is found, this function should return true and set
	   the found solution path in the goal instance contained by
      	   ompl::base::ProblemDefinition. If no solution is found, the
	   function should return false.
	 - The function should terminate within the amount of time specified.
	 - It is desirable that calling solve() multiple times
           consecutively continues the solving process rather than
           restarting it.	  
    - Provide an implementation of ompl::base::Planner::clear(). The
      state of the planner should be restored to what it was at
      creation time.
    - Provide an implementation of
      ompl::base::Planner::getPlannerData(). The provided
      implementation can be empty. This function is provided for
      debugging purposes: it allows the user of the algorithm to
      inspect the constructed exploration datastructure.

      \code 
      #include "ompl/base/Planner.h"
      
      namespace ompl
      {
            class myNewPlanner : public base::Planner
	    {
	    public:
		
		myNewPlanner(const base::SpaceInformationPtr &si) : base::Planner(si, "the planner's name")
		{
		    // the type of goals this planner can handle
		    type_ = base::PLAN_TO_GOAL_REGION;
		}
		
		virtual ~myNewPlanner(void)
		{
		    // free any allocated memory
		}
		
		virtual bool solve(double solveTime)
		{
		    // get problem definition from pdef_
		    // get input states with pis_
		    // call routines from si_

		    // compute a valid motion plan
		    // set it with pdef_->getGoal()->setSolutionPath()

		    return pdef_->getGoal()->isAchieved();
		}
		
		virtual void clear(void)
		{
		    // clear the data structures
		}
		
		virtual void getPlannerData(PlannerData &data) const
		{
		    // fill data with the states and edges that were created
		    // in the exploration data structure
		}
		
	    };
      }
      \endcode
*/
